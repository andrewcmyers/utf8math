package makeutf8;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;
import java.util.TreeMap;
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Locale;

/* Generator for utf8math.sty. (Formerly called utf8.sty)

   Written by Andrew Myers, August 2007.

   Extended to support 4-byte sequences by Jed Liu, February 2010.

   Other small improvements and renaming of the style file, April 2015.
 */

public class Main {

    static final String STYLE = "utf8math";
    static final String VERSION = "1.3";

    static class CharacterInfo {
        boolean math;
	int code;
        String texMacro;
	String digraph;
        
        CharacterInfo(int code_, boolean m, String tm, String vdg) {
	    code = code_;
            math = m;
            texMacro = tm;
	    digraph = vdg;
        }
    }
    
    static class MyFOS extends FileOutputStream {
        MyFOS(String fn) throws FileNotFoundException {
            super(fn);
        }
        void println(String s) throws IOException {
            print(s);
            write('\n');
        }
        void print(String s) throws IOException {
            for (int i = 0; i < s.length(); i++) {
                byte b = (byte) s.charAt(i);
                write(b);
            }
        }
    }

    static class Seq1 extends TreeMap<Byte, CharacterInfo> { }
    static class Seq2 extends TreeMap<Byte, Seq1> {
      Seq1 get(Byte c) {
        Seq1 result = super.get(c);
        if (result == null) {
          result = new Seq1();
          put(c, result);
        }
        return result;
      }
    }
    static class Seq3 extends TreeMap<Byte, Seq2> {
      Seq2 get(Byte c) {
        Seq2 result = super.get(c);
        if (result == null) {
          result = new Seq2();
          put(c, result);
        }
        return result;
      }
    }
    static class Seq4 extends TreeMap<Byte, Seq3> {
      Seq3 get(Byte c) {
        Seq3 result = super.get(c);
        if (result == null) {
          result = new Seq3();
          put(c, result);
        }
        return result;
      }
    }
    
    public static void main(String[] args) {
        MyFOS out;
	PrintWriter vimout;
        Seq2 seq2 = new Seq2();
        Seq3 seq3 = new Seq3();
        Seq4 seq4 = new Seq4();
        
        try {
            out = new MyFOS(STYLE + ".sty");
	    vimout = new PrintWriter(new FileOutputStream("utf8-digraphs.vim"));
            Date today = new Date();
            
            out.println("% " + STYLE + ".sty");
            out.println("% Automatically generated by makeutf8 from utf8.table.");
            out.println("% Generated " + today);
            out.println("% makeutf8 written by Andrew Myers, August 2007."
                        + "Last updated 11/2015.");
	    out.println("");
	    out.println("\\NeedsTeXFormat{LaTeX2e}[2.09]");
            DateFormat df = new SimpleDateFormat("yyyy/MM/dd");
            String date_string = df.format(today);
	    out.println("\\ProvidesPackage{" + STYLE + "}[" + date_string
                        + " " + VERSION + " UTF-8 with math support]");
	    out.println("");
            out.println("\\def\\utf@unrecog{" +
                    "\\ensuremath{\\Box}\\@gobble}");
	    vimout.println("\" Additional digraphs for Unicode characters");

            for (int i = 128; i < 256; i++) {
                out.print("\\catcode" + i);
                out.println("=" + (i >= 194 ? "13" : "12") + "% " +
                        Integer.toHexString(i));
            }
    
            BufferedReader unidata = new BufferedReader(new FileReader("utf8.table"));
            readData(unidata, seq2, seq3, seq4);

            print2Chars(out, vimout, seq2);
            print3Chars(out, vimout, seq3);
            print4Chars(out, vimout, seq4);

            out.close();
	    vimout.close();
            
        } catch (IOException e) {
            System.err.println("IO Error");
            return;
        }
    }
    
    static void readData(BufferedReader unidata, Seq2 seq2, Seq3 seq3, Seq4 seq4)
	    throws IOException {
        while (true) {
            String line = unidata.readLine();
            if (line == null)
                break;
            String[] f = line.split(";");
            if (f.length < 4) {
//                System.err.println("Ignoring " + f[0]);
            } else {
                int code = Integer.parseInt(f[0], 16);
                boolean math = f[2].equals("m");
                String texMacro = f[3];
		String digraph = null;
		if (f.length >= 5) {
		    digraph = f[4];
		}
                CharacterInfo info =
                    new CharacterInfo(code, math, texMacro, digraph);
                if (code >= 0 && code <= 0x7f) {
                } else if (code >= 0x80 && code <= 0x7FF) {
                        byte c1 = (byte)(0xc0 | (code>>6));
                        byte c2 = (byte)(0x80 | (code & 0x3f));
                        seq2.get(c1).put(c2, info);
                } else if (code >= 0x800 && code <= 0xFFFF) {
                        byte c1 = (byte)(0xe0 | (code >> 12));
                        byte c2 = (byte)(0x80 | ((code >> 6) & 0x3f));
                        byte c3 = (byte)(0x80 | (code & 0x3f));
                        seq3.get(c1).get(c2).put(c3, info);
                } else if (code >= 0x10000 && code <= 0x10FFFF) {
                        byte c1 = (byte)(0xf0 | (code >> 18));
                        byte c2 = (byte)(0x80 | ((code >> 12) & 0x3f));
                        byte c3 = (byte)(0x80 | ((code >> 6) & 0x3f));
                        byte c4 = (byte)(0x80 | (code & 0x3f));
                        seq4.get(c1).get(c2).get(c3).put(c4, info);
                }
            }
        }
    }
    
    static void output(MyFOS out, CharacterInfo info) throws IOException {
        if (info.math) {
            out.print("\\ensuremath{");
        }
        out.print(info.texMacro);
        if (info.math) {
            out.print("}");
        }
        out.print("\\@gobble");
    }
    
    static void print2Chars(MyFOS out, PrintWriter vimout,
			    Seq2 seq2)
            throws IOException {
        for (Map.Entry<Byte, Seq1> e1 : seq2.entrySet()) {
            byte c1 = e1.getKey();
            Seq1 t1 = e1.getValue();

            out.print("\\def ");
            out.write(c1);
            out.println("{%");
            int braces = 0;
            for (Map.Entry<Byte, CharacterInfo> e2 : t1.entrySet()) {
                byte c2 = e2.getKey();
                CharacterInfo info = e2.getValue();
                out.print("  \\@ifnextchar " +
                        (char)c2 +
                        "{");
                output(out, info);
                out.println("}{% " + Integer.toHexString(info.code));
                braces++;
            }
            closeBraces(out, braces);
            out.println("}\n");
        }
    }
    static String hex(Integer x) {
        return Integer.toHexString(x.intValue());
    }
    static String enc(byte x) {
        return "" + (char)(65 + ((x>>4) & 0x0f)) + (char)(65 + (x & 0x0f));
    }
    static void closeBraces(MyFOS out, int braces) throws IOException {
        out.print("  \\utf@unrecog");
        for (int j = 0; j < braces; j++) {
            out.print("}");
        }
    }
    static void print3Chars(MyFOS out, PrintWriter vimout,
                            Seq3 seq3) throws IOException {
        for (Map.Entry<Byte, Seq2> e1 : seq3.entrySet()) {
            byte c1 = e1.getKey();
            Seq2 t1 = e1.getValue();
            out.print("\\def ");
            out.write(c1);
            out.println("{%");
            int braces = 0;
            for (byte c2 : t1.keySet()) {
                out.println("  \\@ifnextchar " +
                        (char)c2 +
                        "{\\utf@" + enc(c1) + enc(c2)+"}{%");
                braces++;
            }
            closeBraces(out,braces);
            out.println("}\n");
        }

        for (Map.Entry<Byte, Seq2> e1 : seq3.entrySet()) {
            byte c1 = e1.getKey();
            Seq2 t1 = e1.getValue();
            for (Map.Entry<Byte, Seq1> e2 : t1.entrySet()) {
                byte c2 = e2.getKey();
                Seq1 t2 = e2.getValue();
                out.println("\\def\\utf@" + enc(c1) + enc(c2) + "#1{%");
                int braces = 0;
                for (Map.Entry<Byte, CharacterInfo> e3 : t2.entrySet()) {
                    byte c3 = e3.getKey();
                    CharacterInfo info = e3.getValue();
                    out.print("  \\@ifnextchar ");
                    out.write(c3);
                    out.print("{");
                    output(out, info);
		    if (info.digraph != null) {
			vimout.println("digraph " + info.digraph + " " +
			    info.code);
		    }
                    out.println("}{% " + Integer.toHexString(info.code));
                    braces++;
                }
                closeBraces(out, braces);
                out.println("}\n");
            }
        }
    }
    
    
    static void print4Chars(MyFOS out, PrintWriter vimout, Seq4 seq4)
            throws IOException {
        for (Map.Entry<Byte, Seq3> e1 : seq4.entrySet()) {
            byte c1 = e1.getKey();
            Seq3 t1 = e1.getValue();
            out.print("\\def ");
            out.write(c1);
            out.println("{%");
            int braces = 0;
            for (byte c2 : t1.keySet()) {
                out.println("  \\@ifnextchar " +
                        (char)c2 +
                        "{\\utf@" + enc(c1) + enc(c2) + "}{%");
                braces++;
            }
            closeBraces(out, braces);
            out.println("}\n");
        }
        
        for (Map.Entry<Byte, Seq3> e1 : seq4.entrySet()) {
            byte c1 = e1.getKey();
            Seq3 t1 = e1.getValue();
            for (Map.Entry<Byte, Seq2> e2 : t1.entrySet()) {
                byte c2 = e2.getKey();
                Seq2 t2 = e2.getValue();
                out.println("\\def\\utf@" + enc(c1) + enc(c2) + "#1{%");
                int braces = 0;
                for (byte c3 : t2.keySet()) {
                    out.println("  \\@ifnextchar " +
                            (char) c3 +
                            "{\\utf@" + enc(c1) + enc(c2) + enc(c3) + "}{%");
                    braces++;
                }
                closeBraces(out, braces);
                out.println("}\n");
            }
        }
        
        for (Map.Entry<Byte, Seq3> e1 : seq4.entrySet()) {
            byte c1 = e1.getKey();
            Seq3 t1 = e1.getValue();
            for (Map.Entry<Byte, Seq2> e2 : t1.entrySet()) {
                byte c2 = e2.getKey();
                Seq2 t2 = e2.getValue();
                for (Map.Entry<Byte, Seq1> e3 : t2.entrySet()) {
                    byte c3 = e3.getKey();
                    Seq1 t3 = e3.getValue();
                    out.println("\\def\\utf@" + enc(c1) + enc(c2) + enc(c3) + "#1{%");
                    int braces = 0;
                    for (Map.Entry<Byte, CharacterInfo> e4 : t3.entrySet()) {
                        byte c4 = e4.getKey();
                        CharacterInfo info = e4.getValue();
                        out.print("  \\@ifnextchar ");
                        out.write(c4);
                        out.print("{");
                        output(out, info);
                        if (info.digraph != null) {
                            vimout.println("digraph " + info.digraph + " " +
                                info.code);
                        }
                        out.println("}{% " + Integer.toHexString(info.code));
                        braces++;
                    }
                    closeBraces(out, braces);
                    out.println("}\n");
                }
            }
        }
    }
}
// vim: ts=8
